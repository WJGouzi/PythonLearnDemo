#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
__title__ = ''
__author name__ = 'gouzi'
__create time__ = '2018/1/25'
# code is far away from bugs with the god animal protecting
    I love animals. They taste delicious.
             ┏┓   ┏┓
            ┏┛┻━━━┛┻━━━┓
            ┃    ☃    ┃
            ┃  ┳┛  ┗┳  ┃
            ┃    ┻     ┃
            ┗━┓      ┏━┛
              ┃      ┗━━━━━━━┓
              ┃   神兽保佑    ┣┓
              ┃    永无BUG！ ┏┛
              ┗┓┓┏━━┳━┓ ┏━━━┛
               ┃┫┫    ┃┫┫
               ┗┻┛    ┗┻┛
"""
import copy

# 浅拷贝（也就是赋值了对象的内存地址）
# 浅拷贝的例子1
a = ['1', '2', 3]
b = a.copy()
b[1] = 0
print(a, b)  # ['1', '2', 3] ['1', 0, 3]
#   a中的三个内存地址分别对应的是三个元素
#   b对a进行浅拷贝，那么b也会在内存中开辟一块空间(创建b)去指向a的三个内存地址
#   当b的某个元素进行变化的时候，会在内存中开辟一个新的内存并指向他（也就是重新赋值）
#   a的内存地址依然不会发生变化，所以当b重新赋值的时候，a不会发生变化。


# 浅拷贝例子2
a1 = [[1, 3], 3, 4]
b1 = a1.copy()
b1[0][1] = 7
print(a1, b1)  # [[1, 7], 3, 4] [[1, 7], 3, 4]
#   由于在a1的第一个元素是一个列表，所以a1中的内存指向的是一个列表的地址
#   所以a1指向的三个内存地址分别是: 1> 列表地址  2> 元素2的内存地址 3>元素3的内存地址
#   a1中的列表分别指向的是 元素1和元素2的地址
#   当b1进行浅拷贝的时候，b1指向的三个元素分别对应a1的三个内存地址。
#   当b1的 元素1列表中 的元素进行修改的时候，a1中的 元素1列表中 的内存地址也会跟着改变。
#   也就是说浅拷贝之间的两个对象是有相互关联的。


# 深拷贝（也就是在内存中重新复制一份独立的一个）
b2 = copy.deepcopy(a1) # 对a1进行深拷贝
b2[0][1] = 22
print(a1, b2) # [[1, 7], 3, 4] [[1, 22], 3, 4]
#   需要引入一个模块(copy) 这样就在内存中复制了一份单独的对象。再次进行操作b2的时候就不干扰到a1了。



